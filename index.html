<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Alphabet Spatial Awareness Exercise</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      font-family: sans-serif;
      overflow: hidden;
    }
    button {
      position: fixed;
      top: 0;
    }
    svg {
      display: block;
      width: 100%;
      height: 100%;
      background-color: white;
      transition: background-color 0.5s;
    }
    text {
      text-anchor: middle;
      dominant-baseline: central;
    }
  </style>
</head>
<body>
  <svg>
    <defs>
      <marker id="arrowhead" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="4" markerHeight="4" orient="auto-start-reverse">
        <path d="M 0 0 L 10 5 L 0 10 z" fill="blue"/>
      </marker>
    </defs>
  </svg>
  <button id="visualizeErrors" style="display: none;">Visualize Errors</button>

  <script>
    const config = {
      minSize: 0.01, // fraction of screen size
      maxSize: 0.08, // fraction of screen size
      smileys: ["ðŸ˜Š", "ðŸ˜„", "ðŸ˜ƒ", "ðŸ˜‰", "ðŸ˜†"]
    };

    const key = `${new Date().toISOString().slice(0, 10)}`
    const svg = d3.select("svg");
    const width = window.innerWidth;
    const height = window.innerHeight;
    const centerX = width / 2;
    const centerY = height / 2;

    const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
    const smiley = config.smileys[Math.floor(Math.random() * config.smileys.length)];

    svg.append("text")
      .attr("x", centerX)
      .attr("y", centerY)
      .attr("font-size", `${config.minSize * Math.min(width, height)}px`)
      .text(smiley);

    const nodes = alphabet.map(letter => {
      const angle = Math.random() * 2 * Math.PI;
      const distance = Math.random() * Math.min(centerX, centerY) / 2;
      return {
        letter,
        x: centerX + distance * Math.cos(angle),
        y: centerY + distance * Math.sin(angle),
      };
    });

    const simulation = d3.forceSimulation(nodes)
      .force("charge", d3.forceManyBody().strength(-120))
      .force("center", d3.forceCenter(centerX, centerY))
      .force("collision", d3.forceCollide().radius(d => {
        const distance = Math.hypot(d.x - centerX, d.y - centerY);
        const size = config.minSize + (config.maxSize - config.minSize) * (distance / (Math.hypot(centerX, centerY)));
        return 10 * size * Math.min(centerX, centerY) + 100;
      }))
      .force('x', d3.forceX().x(centerX).strength(2.0*height/(width+height)))
      .force('y', d3.forceY().y(centerY).strength(2.0*width/(width+height)))
      .on("tick", update);

    function update() {
      const texts = svg.selectAll("text.alphabet")
        .data(nodes, d => d.letter);

      texts.enter().append("text")
        .attr("class", "alphabet")
        .text(d => d.letter);
      texts
        .attr("font-size", d => {
          const distance = Math.hypot(d.x - centerX, d.y - centerY);
          return `${(config.minSize + (config.maxSize - config.minSize) * (distance / Math.min(centerX, centerY))) * Math.min(width, height)}px`;
        })
        .attr("x", d => {

          const distance = Math.hypot(d.x - centerX, d.y - centerY);
          const fontSize = (config.minSize + (config.maxSize - config.minSize) * (distance / Math.min(centerX, centerY))) * Math.min(width, height);
          d.x = Math.max(fontSize, Math.min(width-fontSize, d.x));
          return d.x;
        })
        .attr("y", d => {
          const distance = Math.hypot(d.x - centerX, d.y - centerY);
          const fontSize = (config.minSize + (config.maxSize - config.minSize) * (distance / Math.min(centerX, centerY))) * Math.min(width, height);
          d.y = Math.max(fontSize, Math.min(height-fontSize, d.y));
          return d.y;
        });

      texts
        .attr("x", d => d.x)
        .attr("y", d => d.y)
        .attr("font-size", d => {
          const distance = Math.hypot(d.x - centerX, d.y - centerY);
          return `${(config.minSize + (config.maxSize - config.minSize) * (distance / Math.min(centerX, centerY))) * Math.min(width, height)}px`;
        });
    }

  let currentIndex = 0;
  function pageTouch(event) {
      const [x, y] = d3.pointers(event, this)[0];

      let minDist = Infinity;
      let closestNode = null;

      for (const node of nodes) {
        const dist = Math.hypot(node.x - x, node.y - y);
        if (dist < minDist) {
          minDist = dist;
          closestNode = node;
        }
      }

      let correctNode = nodes.find(n => n.letter === alphabet[currentIndex]);
      let letterNearest = closestNode && closestNode.letter
      let correct = closestNode?.letter === correctNode?.letter;

      if (correct) {
        // Correct tap
        svg.transition()
          .style("background-color", "lightgreen")
          .duration(500)
          .on("end", () => svg.style("background-color", "white"));

        currentIndex++;
      } else {
        // Incorrect tap
        svg.style("background-color", "lightcoral");
        setTimeout(() => svg.style("background-color", "white"), 500);
      }

      const tapData = {
        timestamp: new Date().getTime(),
        needed: {
          letter: correctNode.letter,
          x: correctNode.x,
          y: correctNode.y
        },
        tapped: {
          letter: closestNode.letter,
          x: x,
          y: y
        },
        correct,
      };

      const log = JSON.parse(localStorage.getItem(key) || "[]");
      localStorage.setItem(key, JSON.stringify([...log, tapData]));

      if (currentIndex === alphabet.length) {
        onFinish();
      }
    }

    function onFinish() {
      document.getElementById("visualizeErrors").style.display = "block";
    }

    document.getElementById("visualizeErrors").addEventListener("click", function() {
      let tapLogs = JSON.parse(localStorage.getItem(key) || "[]");

      svg.selectAll("line.error")
        .data(tapLogs.filter(l => {
          const errMag = Math.hypot(l.needed.x-l.tapped.x, l.needed.y-l.tapped.y);
          return errMag > 15
        }))
        .join("line")
        .attr("class", "error")
        .attr("x1", d => d.needed.x)
        .attr("y1", d => d.needed.y)
        .attr("x2", d => d.tapped.x)
        .attr("y2", d => d.tapped.y)
        .attr("stroke", "blue")
        .attr("stroke-width", "5")
        .attr("stroke-opacity", "0.2")
        .attr("marker-end", "url(#arrowhead)");

      ;

      svg.selectAll("circle.incorrect")
        .data(tapLogs.filter(d => !d.correct))
        .join("circle")
        .attr("class", "incorrect")
        .attr("cx", d => d.tapped.x)
        .attr("cy", d => d.tapped.y)
        .attr("r", "8")
        .attr("fill", "red")
        .attr("fill-opacity", "0.2");
    });


    document.body.addEventListener("touchstart", pageTouch);

  </script>
</body>
</html>
